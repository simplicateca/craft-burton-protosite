<?php
/**
 * Burton - Normalize Block Twig Extension
 *
 * Splice any fragment block types into the block array.
 *
 * Merges the `settings` objects from the block source, format, frame, and secondary
 * fields (MetaSettings) into a single `settings` object.
 *
 * MetaSettings - https://github.com/simplicateca/craft-meta-settings-field
 */

/**------------------------------------------------------------------------------------/

    BuilderBase() is responsible for 3 primary things:

 1) Explode Fragment blocks into individual blocks and splice them into the block list.

 2) Merge any provided `settings` with the ones generated by the primary attribute
    fields (i.e. source, format, frame, and secondary. Since those three fields are
    typically MetaSettings fields, they provide both a `value` and an array of related
    `settings`.

    Any related attribute settings are merged into the block-level `settings`.

 -> `craftcms/templates/_config`
 -> https://github.com/simplicateca/craft-meta-settings-field


 3) Normalize the object passed to each `block.<entrytype>.twig` template.


    Normalized Block Format
/**------------------------------------------------------------------------------------/
    Looping though a Matrix field typically yields individual EntryTypes objects.
 -> https://craftcms.com/docs/5.x/reference/element-types/entries.html#entry-types

    However, since we want to pass-through an additional `settings` array with each
    block in our builder, we need create our own slightly modify data structure versus
    what gets returned from something like `entry.matrixBuilder.all()`

    For non-manual blocks, we use the `fieldValues` property of the block Entry to
    give us access to all custom field values.

 -> https://docs.craftcms.com/api/v5/craft-base-element.html#property-fieldvalues

    We include our `settings` property and also store to original block entry object
    in `_block` so that the Twig templates never lose access to the full object.
/**----------------------------------------------------------------------------------**/
namespace simplicateca\burton\twigextensions;

use Craft;
use Twig\TwigFunction;
use Twig\Extension\AbstractExtension;

class BuilderBaseTwig extends AbstractExtension {
    public function getFunctions() : array {
        return [
            new TwigFunction( 'BuilderBase', [ $this, 'BuilderBase' ] ),
            new TwigFunction( 'themeChunks', [ $this, 'themeChunks' ] ),
        ];
    }


    public function BuilderBase( mixed $blocks = [], mixed $path = [], ...$varargs ) : array
    {
        $builder = $this->PrepareBlocks( $blocks, $varargs );
        $builder = $this->BlockPaths( $builder, $path );
        return $builder;
    }

    public function PrepareBlocks( mixed $blocks = [], mixed $init ) : array
    {
        $builder = [];
        foreach( is_array( $blocks ) ? $blocks : [] as $block ) {
            $settings = $this->_initSettings( $block, $init );

            $block = $this->_settings([ 'block' => $block, 'settings' => $settings ]);

            if( $block['block']->fragments ?? null ) {

                $isInline = strtolower( $block['settings']['blocktype'] ?? '' )     == 'fragment'
                         && strtolower( $block['settings']['format'] ?? 'default' ) == 'default';

                if( $isInline == true ) {


                    $builder[] = $block;
                    foreach( $block['block']->fragments->all() AS $frag ) {
                        if( $frag->builder ?? null ) {
                            foreach( $frag->builder->all() AS $f ) {
                                $f->setPrimaryOwner( $block['block']->primaryOwner );
                                $inline = $this->_settings( [ 'block' => $f, 'settings' => $settings ] );

                                $inline['settings']['theme'] =
                                    strtolower( $block['settings']['theme'] ?? '' ) == 'fragment'
                                    ? $inline['settings']['theme']
                                    : 'inherit';

                                $builder[] = $inline;
                            }
                        }
                    }
                } else {
                    $builder[] = $block;
                }
            } else {
                $builder[] = $block;
            }
        }
        return $builder;
    }


    public function themeChunks( ?array $blocks = [], ?string $default = '' ): array
    {
        if( !$blocks || empty($blocks) ) {
            return [];
        }

        // Normalize theme values
        $lastTheme = $default;
        foreach ($blocks as $i => &$block) {
            if( empty($block['settings']['theme']) || strtolower( $block['settings']['theme'] ?? '' ) == 'inherit' ) {
                $block['settings']['theme'] = $lastTheme;
            } else {
                $lastTheme = $block['settings']['theme'];
            }
        }
        unset($block); // break reference

        return collect( $blocks )->reduce(
            function ($carry, $item) {
                if (!$carry || $carry->isEmpty()) {
                    return collect([[ $item ]]);
                }

                $lastGroup = $carry->last();
                $lastTheme = $lastGroup[0]['settings']['theme'];
                $currentTheme = $item['settings']['theme'];

                if ($currentTheme === $lastTheme) {
                    $carry->pop();
                    $lastGroup[] = $item;
                    $carry->push($lastGroup);
                } else {
                    $carry->push([$item]);
                }

                return $carry;
            },
        )->all();
    }


    private function _initSettings( $block, $varargs ) : array
    {
        $settings = is_array( $varargs ) ? $varargs : [];
        if( is_array( $block ) && isset( $block['settings'] ) && is_array( $block['settings'] ) ) {
            $settings = array_merge( $settings, $block['settings'] );
        }
        return $settings;
    }


    private function _settings( $b = null ) : array|null
    {
        // empty?!
        if( !$b || empty( $b ) ) { return null; }

        // no block
        if( !isset($b['block']) || empty($b['block']) ) { return null; }

        // still here? cool .. add custom field values
        $fieldData = is_object($b['block'])
            ? collect( $b['block']->fieldValues )->all()
            : $b['block'];

        // initial settings
        $settings = array_merge([
            'id'        => $fieldData['id'] ?? $b['block']->id ?? $b['block']->uid ?? null,
            'blocktype' => $this->getBlockType( $b['block'] ),
            'section'   => $this->getPrimaryOwnerSection( $b['block'] ),
            'entrytype' => $this->getPrimaryOwnerType( $b['block'] ),
            'frame'     => (string) $this->getAttributeValue( $fieldData, 'frame' ),
            'format'    => (string) $this->getAttributeValue( $fieldData, 'format' ),
            'source'    => (string) $this->getAttributeValue( $fieldData, 'source' ),
            'secondary' => (string) $this->getAttributeValue( $fieldData, 'secondary' ),
        ], $b['settings'] ?? []);

        // adding additional field data
        $settings = array_merge( $settings, [
            ...$this->_attrdata( $fieldData, 'frame' ),
            ...$this->_attrdata( $fieldData, 'format' ),
            ...$this->_attrdata( $fieldData, 'source' ),
            ...$this->_attrdata( $fieldData, 'secondary' ),
        ]);

        $b['settings'] = $settings;

        return $b;
    }



    private function BlockPaths( array $blocks = [], mixed $path = [], mixed $keys = [] ) : array
    {
        $replace_keys = is_array( $keys ) && !empty( $keys )
            ? $keys
            : ['blocktype', 'section', 'entrytype', 'frame', 'format', 'source', 'secondary'];

        $lookup_path = is_array( $path ) ? $path : [$path];

        return array_map(function ($block) use ($lookup_path, $replace_keys) {

            $_replacements = array_reduce(
                $replace_keys,
                function ($carry, $key) use ($block) {
                    $carry["%{$key}%"] = $block['settings'][$key] ?? '';
                    return $carry;
                },
                []
            );

            $block['path'] = array_filter(
                array_map(fn($p) => strtr($p, $_replacements), $lookup_path),
                fn($v) => !empty($v)
            );

            return $block;

        }, $blocks );
    }


    // Helper Functions for Accessing $block data
    // ----------------------------------------------------------------------------------
    // Return the (lowercase) blocktype handle (or 'manual' for assumed manual blocks)
    private function getBlockType( $block ) : string {
        $type = is_object( $block )
            ? $block->type->handle
            : ( isset( $block['type'] ) ? $block['type'] : null );
        return strtolower( $type ?? 'manual' );
    }


    // Gets the section handle for the primary owner entry of the block
    private function getPrimaryOwnerSection( $block ) : string|null {
        return $block->primaryOwner->section->handle ?? null;

    }


    // Gets the entry type handle for the primary owner entry of the block
    private function getPrimaryOwnerType( $block ) : string|null {
        return $block->primaryOwner->type->handle ?? null;
    }


    // get the string value of a primary attribute field (frame, format, source, secondary)
    private function getAttributeValue( $values, $attr ) : string|null {
        $value = isset( $values[$attr] )
            ? (string) $values[$attr]
            : '';
        return $value;
    }


    // As the primary attribute fields are typically custom MetaSettings fields, this
    // returns the combined values of any `settings` + `virtuals` values for the field.
    //
    // When building a manual block, these extended field settings typically wouldn't
    // exist. All values needed to render a manual block should be provided directly in
    // that blocks `settings` param.
    private function _attrdata( $values, $attr ) : array|null {
        $result = isset( $values[$attr] )
            ? ( is_object( $values[$attr] ) ? $values[$attr]->settings : [] )
            : ( isset( $values[$attr]['settings'] ) ? $values[$attr]['settings'] : [] );
        return $result;
    }


    // Find all the fragments that exist as part of this block
    // ----------------------------------------------------------------------------------
    // Fragment blocks may contain more than one block and we need to splice them into
    // the block array so that they can be normalized. Luckily fragments can not contain
    // other fragments so we don't have to go recursive on this shit.
    //
    // TODO: Umm.. does Craft 5 with Nested Matrix fields change my opinion of the above?
    private function _fragments( $original, $settings ) : array|null {

        if( $this->getBlockType( $original ) != 'fragment' ) { return null; }
        $fragments = [];

        // each $frag represents an entry added to the "Fragments" entry field
        // now we need to find all the blocks inside each frag
        // TODO: could probably do with some eager loading?
        foreach( $original->fragments->collect() AS $frag ) {
            if( $frag->builder ?? null ) {
                $blocks = $frag->builder->all();
                array_push( $fragments, ...$blocks );
            }
        }

        // Pre-normalize(?) Individual Fragments
        // ------------------------------------------------------------------------------
        // Don't forget to set the Entry Owner of the original Fragment block.
        // This is so that we can make sure that the blocks being spliced into the
        // builder array will report as "belonging" to the entry that the original block
        // was created on rather than an Entry in Reusable Content channel.
        $blocks = [];
        foreach( $fragments AS $block ) {
            $block->setPrimaryOwner( $original->primaryOwner );
            $blocks[] = [
                'block' => $block,
                'settings' => $settings,
                'fragment' => [
                    'block' => $original,
                    'settings' => $settings
                ]
            ];
        }

        return $blocks;
    }
}